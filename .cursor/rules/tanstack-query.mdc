# TanStack Query Usage

Use TanStack Query (React Query) for all data fetching, caching, and server state management.

## Setup

### Query Client Configuration
```typescript
// src/shared/config/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 5 * 60 * 1000, // 5 minutes
      gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)
      retry: 3,
      refetchOnWindowFocus: false,
    },
    mutations: {
      retry: 1,
    },
  },
});
```

### Provider Setup
```typescript
// src/app/_layout.tsx
import { QueryClientProvider } from '@tanstack/react-query';
import { queryClient } from '../shared/config/queryClient';

export default function RootLayout() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* Your app content */}
    </QueryClientProvider>
  );
}
```

## Query Patterns

### Basic Query
```typescript
// src/features/books/hooks/useBooks.ts
import { useQuery } from '@tanstack/react-query';
import { bookApi } from '../services/bookApi';

export const useBooks = () => {
  return useQuery({
    queryKey: ['books'],
    queryFn: bookApi.getBooks,
  });
};
```

### Query with Parameters
```typescript
// src/features/books/hooks/useBook.ts
import { useQuery } from '@tanstack/react-query';
import { bookApi } from '../services/bookApi';

export const useBook = (bookId: string) => {
  return useQuery({
    queryKey: ['books', bookId],
    queryFn: () => bookApi.getBook(bookId),
    enabled: !!bookId, // Only run if bookId exists
  });
};
```

### Query with Search Parameters
```typescript
// src/features/books/hooks/useBookSearch.ts
import { useQuery } from '@tanstack/react-query';
import { bookApi } from '../services/bookApi';
import { BookSearchParams } from '../types/book.types';

export const useBookSearch = (params: BookSearchParams) => {
  return useQuery({
    queryKey: ['books', 'search', params],
    queryFn: () => bookApi.searchBooks(params),
    enabled: !!params.query || !!params.category,
  });
};
```

## Mutation Patterns

### Basic Mutation
```typescript
// src/features/books/hooks/useBorrowBook.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { bookApi } from '../services/bookApi';

export const useBorrowBook = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: bookApi.borrowBook,
    onSuccess: (data, bookId) => {
      // Invalidate and refetch books list
      queryClient.invalidateQueries({ queryKey: ['books'] });
      
      // Update specific book in cache
      queryClient.setQueryData(['books', bookId], (oldData) => ({
        ...oldData,
        available: false,
      }));
    },
    onError: (error) => {
      console.error('Failed to borrow book:', error);
    },
  });
};
```

### Optimistic Updates
```typescript
// src/features/books/hooks/useBorrowBookOptimistic.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { bookApi } from '../services/bookApi';

export const useBorrowBookOptimistic = () => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: bookApi.borrowBook,
    onMutate: async (bookId) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: ['books'] });
      
      // Snapshot previous value
      const previousBooks = queryClient.getQueryData(['books']);
      
      // Optimistically update
      queryClient.setQueryData(['books'], (old: Book[]) =>
        old.map(book =>
          book.id === bookId ? { ...book, available: false } : book
        )
      );
      
      return { previousBooks };
    },
    onError: (err, bookId, context) => {
      // Rollback on error
      queryClient.setQueryData(['books'], context?.previousBooks);
    },
    onSettled: () => {
      // Always refetch after error or success
      queryClient.invalidateQueries({ queryKey: ['books'] });
    },
  });
};
```

## Query Keys

### Consistent Query Key Structure
```typescript
// Query key factory
export const bookKeys = {
  all: ['books'] as const,
  lists: () => [...bookKeys.all, 'list'] as const,
  list: (filters: BookSearchParams) => [...bookKeys.lists(), filters] as const,
  details: () => [...bookKeys.all, 'detail'] as const,
  detail: (id: string) => [...bookKeys.details(), id] as const,
};

// Usage
export const useBooks = () => {
  return useQuery({
    queryKey: bookKeys.lists(),
    queryFn: bookApi.getBooks,
  });
};

export const useBook = (id: string) => {
  return useQuery({
    queryKey: bookKeys.detail(id),
    queryFn: () => bookApi.getBook(id),
  });
};
```

## Error Handling

### Global Error Handling
```typescript
// src/shared/hooks/useQueryError.ts
import { useQueryErrorResetBoundary } from '@tanstack/react-query';
import { ErrorBoundary } from 'react-error-boundary';

export const QueryErrorBoundary: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const { reset } = useQueryErrorResetBoundary();
  
  return (
    <ErrorBoundary
      onReset={reset}
      fallbackRender={({ error, resetErrorBoundary }) => (
        <ErrorFallback error={error} resetErrorBoundary={resetErrorBoundary} />
      )}
    >
      {children}
    </ErrorBoundary>
  );
};
```

### Component Error Handling
```typescript
// src/features/books/components/BookList.tsx
import { useBooks } from '../hooks/useBooks';

export const BookList: React.FC = () => {
  const { data: books, isLoading, error, refetch } = useBooks();
  
  if (isLoading) return <LoadingSpinner />;
  
  if (error) {
    return (
      <ErrorView 
        error={error} 
        onRetry={refetch}
        message="Failed to load books"
      />
    );
  }
  
  return (
    <FlatList
      data={books}
      renderItem={({ item }) => <BookCard book={item} />}
      keyExtractor={(item) => item.id}
    />
  );
};
```

## Best Practices

### 1. Custom Hooks
Always wrap queries in custom hooks for reusability and type safety:
```typescript
export const useBooks = () => {
  return useQuery({
    queryKey: ['books'],
    queryFn: bookApi.getBooks,
  });
};
```

### 2. Type Safety
Use TypeScript for better type safety:
```typescript
export const useBooks = (): UseQueryResult<Book[], Error> => {
  return useQuery<Book[], Error>({
    queryKey: ['books'],
    queryFn: bookApi.getBooks,
  });
};
```

### 3. Query Invalidation
Invalidate related queries after mutations:
```typescript
onSuccess: () => {
  queryClient.invalidateQueries({ queryKey: ['books'] });
  queryClient.invalidateQueries({ queryKey: ['user', 'borrowed'] });
},
```

### 4. Background Refetching
Use `refetchOnWindowFocus` and `refetchOnReconnect` appropriately:
```typescript
export const useBooks = () => {
  return useQuery({
    queryKey: ['books'],
    queryFn: bookApi.getBooks,
    refetchOnWindowFocus: false, // Disable for static data
    refetchOnReconnect: true,    // Enable for important data
  });
};
```

### 5. Prefetching
Prefetch data for better UX:
```typescript
// Prefetch book details when hovering over book card
const prefetchBook = (bookId: string) => {
  queryClient.prefetchQuery({
    queryKey: ['books', bookId],
    queryFn: () => bookApi.getBook(bookId),
  });
};
```
description:
globs:
alwaysApply: true
---
